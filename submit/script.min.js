const canvas = document.getElementById('canvas'),
  ctx = canvas.getContext('2d');
let canvasPosition = getPositionRelativeToCanvas(canvas),
  mouseX = 0,
  mouseY = 0;
const blu = '#6a6aff',
  grn = '#bad500',
  red = '#ff6a6a',
  rrr = '#ff0000',
  gry = '#6a6a6a';
let tick = 0,
  score = 0,
  roundScore = 0,
  activeCollisionHappening = !1,
  parriedCount = 0;
const totalScore = document.getElementById('score'),
  info = document.getElementById('info'),
  startInfo = document.getElementById('start-info'),
  enemyInfo = document.getElementById('enemy-info'),
  nextEnemy = document.getElementById('next-enemy'),
  nextEnemyDescription = document.getElementById('next-enemy-description'),
  go = document.getElementById('go'),
  goSound = document.getElementById('go-sound'),
  roundInfo = document.getElementById('round-info'),
  previousRoundResults = document.getElementById('previous-round-results'),
  yourScore = document.getElementById('your-score'),
  totalPossibleScore = document.getElementById('total-possible-score'),
  scorePercent = document.getElementById('score-percent'),
  yourParries = document.getElementById('your-parries'),
  totalPossibleParries = document.getElementById('total-possible-parries'),
  parriesPercent = document.getElementById('parries-percent'),
  lastInfo = document.getElementById('last-info'),
  reloadButton = document.getElementById('reload-button'),
  reload = document.getElementById('reload'),
  timeUntilParried = 33;
let hasSound = !1;
const lastHighScore = localStorage.getItem('parryHighScore') || 0,
  newHighScore = document.getElementById('new-high-score'),
  highScore = document.getElementById('high-score'),
  lastParryAngle = document.getElementById('last-parry-angle'),
  lastParryScore = document.getElementById('last-parry-score');
class Sword {
  constructor({
    position: t = { x: 0, y: 0 },
    color: e = gry,
    defaultColor: o = gry,
    collidingColor: n = red,
    width: i = 10,
    height: r = 100,
    rotationAngle: a = 0,
    isColliding: s = !1,
    timeSpentColliding: l = 0,
    timeSpentOnScreen: d = 0,
    id: c = tick,
    sliced: h = !1,
  }) {
    (this.position = t),
      (this.color = e),
      (this.defaultColor = o),
      (this.collidingColor = n),
      (this.width = i),
      (this.height = r),
      (this.rotationAngle = a),
      (this.isColliding = s),
      (this.timeSpentColliding = l),
      (this.timeSpentOnScreen = d),
      (this.id = c),
      (this.sliced = h);
  }
  draw() {
    ctx.beginPath(),
      this.id < 50
        ? (ctx.fillStyle = activeCollisionHappening
            ? this.makeGradient(
                (this.timeSpentColliding * (100 / timeUntilParried)) / 100
              )
            : this.color)
        : (this.slicing && (this.color = rrr),
          this.sliced ||
            (ctx.fillStyle = this.makeGradient(
              (this.timeSpentOnScreen * (100 / this.timeUntilSliced)) / 100
            )));
    const t = this.position.x,
      e = this.position.y;
    ctx.moveTo(t - 5, e),
      ctx.lineTo(t - 5, e - this.height),
      ctx.lineTo(t, e - this.height - 10),
      ctx.lineTo(t + 5, e - this.height),
      ctx.lineTo(t + 5, e),
      ctx.lineTo(t - 5, e),
      ctx.fill();
  }
  drawRotation() {
    ctx.save(),
      ctx.translate(this.position.x, this.position.y),
      ctx.rotate((this.rotationAngle * Math.PI) / 180),
      ctx.translate(-this.position.x, -this.position.y),
      this.draw(),
      ctx.restore();
  }
  makeGradient(t) {
    const e = this.position.x - this.width / 2,
      o = this.position.y,
      n = this.position.x + this.width / 2,
      i = this.position.y - this.height - 10;
    let r = t > 1 ? 1 : t;
    const a = ctx.createLinearGradient(e, o, n, i);
    return (
      a.addColorStop(0, this.color),
      a.addColorStop(r, this.color),
      a.addColorStop(r, this.collidingColor),
      a.addColorStop(1, this.collidingColor),
      a
    );
  }
}
class PlayerSword extends Sword {
  constructor() {
    super({
      position: { x: mouseX, y: mouseY },
      color: blu,
      defaultColor: blu,
      collidingColor: grn,
    });
  }
  checkSwordRotation() {
    keyStateForPlayerSwordRotation.q &&
      this.rotationAngle >= -81 &&
      (this.rotationAngle -= 9),
      keyStateForPlayerSwordRotation.e &&
        this.rotationAngle <= 81 &&
        (this.rotationAngle += 9),
      this.drawRotation();
  }
  determineTimeSpentColliding() {
    this.isColliding && this.timeSpentColliding++;
  }
}
const ps = new PlayerSword();
let keyStateForPlayerSwordRotation = { q: !1, e: !1 };
document.addEventListener('keydown', (t) => {
  'q' === t.key
    ? (keyStateForPlayerSwordRotation.q = !0)
    : 'e' === t.key && (keyStateForPlayerSwordRotation.e = !0);
}),
  document.addEventListener('keyup', (t) => {
    'q' === t.key
      ? (keyStateForPlayerSwordRotation.q = !1)
      : 'e' === t.key && (keyStateForPlayerSwordRotation.e = !1);
  });
const enemySwordLocation = getRandomConstrainedLocation(100, 600, 100, 400);
class EnemySword extends Sword {
  constructor(t = !1, e = !1, o = 75) {
    super({
      position: { x: enemySwordLocation.x, y: enemySwordLocation.y },
      color: red,
      defaultColor: red,
      collidingColor: gry,
    }),
      (this.parried = t),
      (this.slicing = e),
      (this.timeUntilSliced = o);
  }
  handleSlice() {
    this.timeSpentOnScreen >= this.timeUntilSliced &&
      ((this.slicing = !0),
      tick % 50 == 0 &&
        (changeScore(90, !1),
        (this.slicing = !1),
        (this.sliced = !0),
        (lastParryAngle.textContent = '-'),
        (lastParryScore.textContent = -90),
        hasSound &&
          zzfx(
            ...[
              ,
              ,
              1e3,
              0.02,
              0.1,
              0.12,
              1,
              1.78,
              -9.5,
              0.2,
              ,
              ,
              ,
              0.1,
              ,
              ,
              ,
              0.47,
              0.02,
              0.06,
            ]
          )));
  }
  handleParry() {
    if (this.timeSpentColliding >= timeUntilParried) {
      const [t, e] = calculatePoints(this.rotationAngle, ps.rotationAngle);
      changeScore(e, !0),
        (lastParryAngle.textContent = `${t}Â°`),
        (lastParryScore.textContent = e),
        (this.parried = !0),
        parriedCount++,
        (activeCollisionHappening = !1),
        hasSound &&
          zzfx(
            ...[
              ,
              ,
              1300,
              0.02,
              0.1,
              0.12,
              1,
              1.78,
              -9.5,
              0.2,
              ,
              ,
              ,
              0.1,
              ,
              ,
              ,
              0.47,
              0.02,
              0.06,
            ]
          );
    }
    this.isColliding
      ? (this.timeSpentColliding++, (activeCollisionHappening = !0))
      : (this.timeSpentOnScreen++,
        this.timeSpentColliding > 0 && this.timeSpentColliding--);
  }
}
let lastComboIndex,
  enemyState = -1,
  gameState = !1,
  pushedSwords = 0;
function changeToInfoState() {
  -1 === enemyState
    ? (roundInfo.style.display = 'none')
    : ((roundInfo.style.display = 'block'),
      (startInfo.style.display = 'none'),
      (goSound.style.display = 'none')),
    handleInfoChange();
}
function stopGameLoop() {
  cancelAnimationFrame(requestId), (gameState = !1);
}
function handleInfoChange() {
  if ((stopGameLoop(), enemyState > -1)) {
    let t = ENEMIES[enemyState].numberOfAttacks;
    (previousRoundResults.textContent = determineRoundRating(t)),
      (scorePercent.textContent = Math.round((roundScore / (100 * t)) * 100)),
      (yourParries.textContent = parriedCount),
      (totalPossibleParries.textContent = t),
      (parriesPercent.textContent = Math.round((parriedCount / t) * 100)),
      (yourScore.textContent = roundScore),
      (totalPossibleScore.textContent = 100 * t);
  }
  (enemyState += 1),
    (info.style.display = 'flex'),
    enemyState === ENEMIES.length
      ? ((lastInfo.style.display = 'flex'),
        (enemyInfo.style.display = 'none'),
        updateLocalStorage())
      : ((enemyInfo.style.display = 'flex'),
        (nextEnemy.textContent = ENEMIES[enemyState].name),
        (nextEnemyDescription.textContent = ENEMIES[enemyState].description),
        (go.textContent = ENEMIES[enemyState].button));
}
function updateLocalStorage() {
  score > lastHighScore &&
    (localStorage.setItem('parryHighScore', score),
    (newHighScore.style.display = 'block')),
    (highScore.textContent = localStorage.getItem('parryHighScore'));
}
function determineRoundRating(t) {
  const e = [
      'Parrylously bad.',
      'Parryble... (terrible).',
      'Not quite up to par(ry).',
      'Not parryticularly notable.',
      'Somewhat imparryssive...',
      'Parretty good...',
      'Parry good!',
      'Extraordinparry!',
      'Legendparry!',
    ],
    o = 100 * t;
  for (let t = 1; t <= e.length; t++)
    if (roundScore <= o * (t / e.length)) return e[t - 1];
}
function changeToGameState() {
  (parriedCount = 0),
    (roundScore = 0),
    (pushedSwords = 0),
    (activeSwords.length = 0),
    activeSwords.push(ps),
    (info.style.display = 'none'),
    (gameState = !0),
    (requestId = requestAnimationFrame(gameLoop));
}
function peasant() {
  pushedSwords < 5
    ? pushSword(250, 100, 600, 100, 400, chooseRandomly(0, 90))
    : pushedSwords < 10
    ? pushSword(100, 100, 600, 100, 400, getRandomInt(0, 359))
    : transitionToNextStage(375);
}
function barbarian() {
  const t = (pushedSwords % 4) * 150 + 100;
  pushedSwords < 4
    ? pushSword(50, t, t, 100, 100, 90)
    : pushedSwords < 8
    ? pushSword(50, t, t, 225, 225, 0)
    : pushedSwords < 12
    ? pushSword(50, t, t, 350, 350, 90)
    : pushedSwords < 16
    ? pushSword(50, t, t, 475, 475, 0)
    : transitionToNextStage(400);
}
function paladin() {
  const t = (pushedSwords % 4) * 150 + 100;
  pushedSwords < 4
    ? pushSword(50, t, t, 110, 110, getRandomInt(0, 359))
    : pushedSwords < 8
    ? pushSword(50, t, t, 220, 220, getRandomInt(0, 359))
    : pushedSwords < 12
    ? pushSword(50, t, t, 330, 330, getRandomInt(0, 359))
    : pushedSwords < 16
    ? pushSword(50, t, t, 440, 440, getRandomInt(-100, 100))
    : transitionToNextStage();
}
function duelist() {
  const t = [100, 225, 350, 475];
  let e;
  pushedSwords < 16
    ? (pushedSwords < 4
        ? (e = 150)
        : pushedSwords < 8
        ? (e = 600)
        : pushedSwords < 12
        ? (e = 300)
        : pushedSwords < 16 && (e = 500),
      pushSword(
        50,
        pushedSwords % 2 == 0 ? e : e - 45,
        pushedSwords % 2 == 0 ? e : e - 45,
        t[pushedSwords % 4],
        t[pushedSwords % 4],
        pushedSwords % 2 == 0 ? -45 : 45
      ))
    : transitionToNextStage(700);
}
function archer() {
  const t = [
    { x: 25, y: 100, a: 45 },
    { x: 675, y: 100, a: -45 },
    { x: 100, y: 475, a: -45 },
    { x: 600, y: 475, a: 45 },
  ];
  let e, o;
  if (pushedSwords < 10)
    tick % 75 == 0 &&
      ((o = getRandomInt(0, 3)) === lastComboIndex &&
        (o = lastComboIndex === t.length - 1 ? 0 : lastComboIndex + 1),
      (lastComboIndex = o),
      pushSword(1, (e = t[o]).x, e.x, e.y, e.y, e.a));
  else if (pushedSwords < 26) {
    if (tick % 150 == 0) {
      let e = getRandomInt(0, 3),
        o = getRandomInt(0, 3);
      for (; e === o; ) o = getRandomInt(0, 3);
      pushSword(1, t[e].x, t[e].x, t[e].y, t[e].y, t[e].a, 125),
        pushSword(1, t[o].x, t[o].x, t[o].y, t[o].y, t[o].a, 125, !1);
    }
  } else transitionToNextStage(666);
}
function dualWielder() {
  if (pushedSwords < 32) {
    const t = getRandomInt(75, 600),
      e = getRandomInt(100, 475),
      o = [
        { angle: 0, x2a: 30, y2a: 0 },
        { angle: 90, x2a: 0, y2a: -30 },
        { angle: 45, x2a: 20, y2a: 20 },
      ],
      n = Math.floor(Math.random() * o.length);
    let i = t + o[n].x2a,
      r = e + o[n].y2a;
    pushSword(75, t, t, e, e, o[n].angle, 37),
      pushSword(75, i, i, r, r, o[n].angle, 37, !1);
  } else transitionToNextStage(400);
}
function transitionToNextStage(t = 200) {
  tick % t == 0 && changeToInfoState();
}
(go.onclick = () => {
  gameState < ENEMIES.length - 1 && changeToGameState();
}),
  (goSound.onclick = () => {
    changeToGameState(), (zzfxX = new AudioContext()), (hasSound = !0);
  });
const ENEMIES = [
  {
    name: 'Peasant',
    description: '"Slow but unpredictable."',
    button: 'Start (without sound)',
    fx: peasant,
    numberOfAttacks: 10,
  },
  {
    name: 'Barbarian',
    description: '"Quick but predictable."',
    button: "I'm barbarian to it",
    fx: barbarian,
    numberOfAttacks: 16,
  },
  {
    name: 'Paladin',
    description: '"High intelligence barbarian."',
    button: "I'm paladin to it",
    fx: paladin,
    numberOfAttacks: 16,
  },
  {
    name: 'Archer',
    description: '"Long-ranged sniper."',
    button: 'Ready, set, bow',
    fx: archer,
    numberOfAttacks: 26,
  },
  {
    name: 'Duelist',
    description: '"Skilled and precise."',
    button: "Let's duel it",
    fx: duelist,
    numberOfAttacks: 16,
  },
  {
    name: 'Dual Wielder',
    description: '"High-speed assassin."',
    button: "Let's dual it",
    fx: dualWielder,
    numberOfAttacks: 32,
  },
];
function pushSword(t, e, o, n, i, r, a = 75, s = !0) {
  if (tick % t == 0) {
    const t = new EnemySword(),
      l = getRandomConstrainedLocation(e, o, n, i);
    (t.position = l),
      (t.rotationAngle = r),
      (t.timeUntilSliced = a),
      activeSwords.push(t),
      hasSound &&
        s &&
        zzfx(
          ...[
            ,
            ,
            90,
            0.02,
            0.06,
            0.07,
            1,
            0.13,
            ,
            ,
            ,
            ,
            ,
            0.2,
            ,
            0.3,
            ,
            0.91,
            0.08,
            0.15,
          ]
        ),
      pushedSwords++;
  }
}
function rotatedCoordinatesHelper(t, e, o, n, i) {
  i = (i * Math.PI) / 180;
  let r = o - t,
    a = n - e,
    s = Math.sqrt(r * r + a * a),
    l = Math.atan2(a, r);
  return { x: t + s * Math.cos(l + i), y: e + s * Math.sin(l + i) };
}
function getRotatedCoordinates(t) {
  let e = t.position.x + t.width / 2,
    o = t.position.y + t.height;
  return {
    topLeft: rotatedCoordinatesHelper(
      e,
      o,
      t.position.x,
      t.position.y,
      t.rotationAngle
    ),
    topRight: rotatedCoordinatesHelper(
      e,
      o,
      t.position.x + t.width,
      t.position.y,
      t.rotationAngle
    ),
    bottomLeft: rotatedCoordinatesHelper(
      e,
      o,
      t.position.x,
      t.position.y + t.height,
      t.rotationAngle
    ),
    bottomRight: rotatedCoordinatesHelper(
      e,
      o,
      t.position.x + t.width / 2,
      t.position.y + t.height,
      t.rotationAngle
    ),
  };
}
function xy(t, e) {
  (this.x = t), (this.y = e);
}
function polygon(t, e) {
  (this.vertex = t), (this.edge = e);
}
function isColliding(t, e) {
  let o = null,
    n = 0,
    i = [],
    r = null,
    a = null,
    s = null,
    l = null;
  for (let e = 0; e < t.edge.length; e++)
    (o = new xy(-t.edge[e].y, t.edge[e].x)), i.push(o);
  for (let t = 0; t < e.edge.length; t++)
    (o = new xy(-e.edge[t].y, e.edge[t].x)), i.push(o);
  for (let o = 0; o < i.length; o++) {
    (r = null), (a = null), (s = null), (l = null);
    for (let e = 0; e < t.vertex.length; e++)
      (n = t.vertex[e].x * i[o].x + t.vertex[e].y * i[o].y),
        (null === a || n > a) && (a = n),
        (null === r || n < r) && (r = n);
    for (let t = 0; t < e.vertex.length; t++)
      (n = e.vertex[t].x * i[o].x + e.vertex[t].y * i[o].y),
        (null === l || n > l) && (l = n),
        (null === s || n < s) && (s = n);
    if (!((r < l && r > s) || (s < a && s > r))) return !1;
  }
  return !0;
}
function detectRectangleCollision(t) {
  if (0 === t) return;
  const e = activeSwords[t];
  if (e.slicing) return;
  const o = activeSwords[0];
  let n = getRotatedCoordinates(e),
    i = getRotatedCoordinates(o),
    r = [
      new xy(n.topRight.x, n.topRight.y),
      new xy(n.bottomRight.x, n.bottomRight.y),
      new xy(n.bottomLeft.x, n.bottomLeft.y),
      new xy(n.topLeft.x, n.topLeft.y),
    ],
    a = [
      new xy(n.bottomRight.x - n.topRight.x, n.bottomRight.y - n.topRight.y),
      new xy(
        n.bottomLeft.x - n.bottomRight.x,
        n.bottomLeft.y - n.bottomRight.y
      ),
      new xy(n.topLeft.x - n.bottomLeft.x, n.topLeft.y - n.bottomLeft.y),
      new xy(n.topRight.x - n.topLeft.x, n.topRight.y - n.topLeft.y),
    ],
    s = [
      new xy(i.topRight.x, i.topRight.y),
      new xy(i.bottomRight.x, i.bottomRight.y),
      new xy(i.bottomLeft.x, i.bottomLeft.y),
      new xy(i.topLeft.x, i.topLeft.y),
    ],
    l = [
      new xy(i.bottomRight.x - i.topRight.x, i.bottomRight.y - i.topRight.y),
      new xy(
        i.bottomLeft.x - i.bottomRight.x,
        i.bottomLeft.y - i.bottomRight.y
      ),
      new xy(i.topLeft.x - i.bottomLeft.x, i.topLeft.y - i.bottomLeft.y),
      new xy(i.topRight.x - i.topLeft.x, i.topRight.y - i.topLeft.y),
    ];
  isColliding(new polygon(r, a), new polygon(s, l))
    ? ((e.isColliding = !0),
      (o.isColliding = !0),
      (o.timeSpentColliding = e.timeSpentColliding))
    : ((e.isColliding = !1),
      (o.isColliding = !1),
      (e.color = e.defaultColor),
      0 === e.rotationAngle &&
        0 === o.rotationAngle &&
        (e.position.x > o.position.x + o.width ||
          e.position.x + e.width < o.position.x ||
          e.position.y > o.position.y + o.height ||
          e.position.y + e.height < o.position.y ||
          (e.color = red)));
}
function getPositionRelativeToCanvas(t) {
  let e = 0,
    o = 0;
  for (; t; )
    (e += t.offsetLeft - t.scrollLeft + t.clientLeft),
      (o += t.offsetTop - t.scrollTop + t.clientTop),
      (t = t.offsetParent);
  return { x: e, y: o };
}
function setMousePositionForPlayerSword(t) {
  (mouseX = t.clientX - canvasPosition.x),
    (mouseY = t.clientY - canvasPosition.y),
    (ps.position.x = mouseX),
    (ps.position.y = mouseY);
}
function getRandomInt(t, e) {
  return Math.floor(Math.random() * (e - t + 1)) + t;
}
function chooseRandomly(t, e) {
  return Math.random() > 0.5 ? t : e;
}
function getRandomConstrainedLocation(t, e, o, n) {
  return {
    x: Math.random() * (e - t + 1) + t,
    y: Math.random() * (n - o + 1) + o,
  };
}
function calculatePoints(t, e) {
  const o = Math.abs(((((t - e + 180) % 360) + 360) % 360) - 180),
    n = Math.round(100 - (Math.abs(90 - o) / 90) * 100);
  return [o, Math.max(0, Math.min(100, n))];
}
function changeScore(t, e) {
  e ? ((score += t), (roundScore += t)) : ((score -= t), (roundScore -= t)),
    (totalScore.textContent = score);
}
canvas.addEventListener('mousemove', setMousePositionForPlayerSword),
  (zzfxV = 0.3),
  (zzfx = (
    t = 1,
    e = 0.05,
    o = 220,
    n = 0,
    i = 0,
    r = 0.1,
    a = 0,
    s = 1,
    l = 0,
    d = 0,
    c = 0,
    h = 0,
    u = 0,
    g = 0,
    p = 0,
    y = 0,
    m = 0,
    S = 1,
    x = 0,
    f = 0,
    w = Math,
    C = 44100,
    b = 2 * w.PI,
    I = (l *= (500 * b) / C / C),
    R = (o *= ((1 - e + 2 * e * w.random((e = []))) * b) / C),
    E = 0,
    P = 0,
    L = 0,
    v = 1,
    k = 0,
    A = 0,
    M = 0,
    B,
    T
  ) => {
    for (
      d *= (500 * b) / C ** 3,
        p *= b / C,
        c *= b / C,
        h *= C,
        u = (C * u) | 0,
        T = ((n = C * n + 9) + (x *= C) + (i *= C) + (r *= C) + (m *= C)) | 0;
      L < T;
      e[L++] = M
    )
      ++A % ((100 * y) | 0) ||
        ((M = a
          ? 1 < a
            ? 2 < a
              ? 3 < a
                ? w.sin((E % b) ** 3)
                : w.max(w.min(w.tan(E), 1), -1)
              : 1 - (((((2 * E) / b) % 2) + 2) % 2)
            : 1 - 4 * w.abs(w.round(E / b) - E / b)
          : w.sin(E)),
        (M =
          (u ? 1 - f + f * w.sin((b * L) / u) : 1) *
          (0 < M ? 1 : -1) *
          w.abs(M) ** s *
          zzfxV *
          t *
          (L < n
            ? L / n
            : L < n + x
            ? 1 - ((L - n) / x) * (1 - S)
            : L < n + x + i
            ? S
            : L < T - m
            ? ((T - L - m) / r) * S
            : 0)),
        (M = m
          ? M / 2 +
            (m > L ? 0 : ((L < T - m ? 1 : (T - L) / m) * e[(L - m) | 0]) / 2)
          : M)),
        (E +=
          (B = (o += l += d) * w.cos(p * P++)) -
          B * g * (1 - ((1e9 * (w.sin(L) + 1)) % 2))),
        v && ++v > h && ((o += c), (R += c), (v = 0)),
        !u || ++k % u || ((o = R), (l = I));
    return (
      (t = zzfxX.createBuffer(1, T, C)).getChannelData(0).set(e),
      ((o = zzfxX.createBufferSource()).buffer = t),
      o.connect(zzfxX.destination),
      o.start(),
      o
    );
  });
const activeSwords = [ps];
let requestId;
function gameLoop() {
  gameState &&
    (tick++,
    ctx.clearRect(0, 0, canvas.width, canvas.height),
    ps.checkSwordRotation(),
    ps.determineTimeSpentColliding(),
    activeSwords.forEach((t, e) => {
      0 === e ||
        t.parried ||
        t.sliced ||
        (detectRectangleCollision(e),
        t.drawRotation(),
        t.handleParry(),
        t.handleSlice());
    }),
    ENEMIES[enemyState].fx(),
    (requestId = requestAnimationFrame(gameLoop)));
}
activeSwords.forEach((t, e) => {
  detectRectangleCollision(e);
}),
  changeToInfoState();
